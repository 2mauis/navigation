# 任务
- [ ] 门牌位置提取
- [ ] 门牌字符识别

## 门牌位置提取  
小车在移动过程中不断拍摄图像，首先需要识别图像中是否出现门牌，如果出现，还需要找出门牌的位置，分割出字符进行识别。
### MSER
Neumann等人提出了一个基于最大稳定极值区域（MSER）的方法用来检测文字。MSER的基本原理是对一幅灰度图像取阈值进行二值化处理，阈值从0到255依次递增。在递增过程中，图像中存在某些连通区域变化很小，则该区域被称为最大稳定极值区域，数学定义为：  

q(i)=|Qi+△-Qi-△|/|Qi| (to be rewrited)  

其中，Qi表示阈值为i时的某一连通区域，△为灰度阈值的微小变化量，q(i)为阈值是i时的区域Qi的变化率。当q(i)为局部极小值时，则Qi为最大稳定极值区域。  
需要说明的是，上述做法只能检测出灰度图像的黑色区域，不能检测出白色区域，因此还需要对原图进行反转，然后再进行阈值从0～255的二值化处理过程。这两种操作又分别称为MSER+和MSER-。

MSER具有以下特点：

1、对图像灰度具有仿射变换的不变性；  
2、稳定性：具有相同阈值范围内所支持的区域才会被选择；  
3、无需任何平滑处理就可以实现多尺度检测，即小的和大的结构都可以被检测到。  

一些MSER效果图（to do）  


由于MSER提取出来的候选框比较多，直接进行字符识别会极大降低识别速度，因此还需要一些方法对候选框进行筛选
### SWT
文字的笔画宽度变化范围不大，基于这一先验经验，Boris等人提出了一种名为stroke width transform（SWT）的算法。

一、The Stroke Width Transform ：  
1、利用Canny edge detector对图像进行边缘检测，得到的每个边缘像素点p都具有一个方向梯度值dp；  
2、若p位于笔画边缘，dp一定大致垂直于笔画方向，沿着射线 r=p+n*dp (n>=0)梯度查找与之对应的另一个边缘像素点q，那么dp与dq的方向是大致相反的（dp = dq ± π/6 ) ，此时会出现两种情况：  
（1）p找不到对应的匹配的q或者dp 与dq不满足大致反向的要求，那么该射线r 废弃掉；  
（2）如果找到满足要求的q那么在[p,q]这条路线上的每个像素点都会被指定笔画宽度属性值||p-q||(欧式距离)，除非该店已经被指定了一个更小的笔画宽度属性值。  
3、重复步骤2，计算出所有未被废弃的路线上的像素的笔画宽度值，算法结束。  

注意：  
（1）这一方法实质上就在对于每个可能属于文字部分的像素点与它最有可能所属的笔画建立联系，这一联系就是该笔画的宽度，可以想见的在未来的处理中，将会对该值相近的连通候选区域进行聚类，即认为他们属于同一笔画，进一步的可以构造出每个笔画，形成文字区域。  
（2）在上述的过程中，实际上是默认了针对于亮底暗字的正向文本，如果是对于暗底亮字的反向文本，那在步骤2中就需要沿着dp的返方向来查找q，这样，在实际算法的推行过程中，是需要重复以上过程两次的：一次沿着dp方向，另一次则沿着-dp方向。  

二、Finding letter candidates：  
这一步要做的是，对于过程一中找到的候选文字狱加以剔除的处理，鉴于上一步骤中得到的结果可能存在干扰（如电线杆可能被识别为文字候选域），需要进一步的处理，主要有以下部分：  
（1）计算每个连通候选区域各个像素点笔画宽度属性值的最大差值，对于差值太大的情况加以排除，这可以排除掉如树叶这样的区域，此处的 阙值设定为连通区域笔画宽度属性之平均值的一半；  
（2）对于候选区域长宽比要求在0.1到10之间，不符合要求的剔除掉，对于电线杆等长宽比较大的区域可以排除；  
（3）一块区域的边界框包含不超过两块区域，以消除文本外围包围线之类（符号框架）；  
（4）对于太大或太小的连通域也排除掉；  
（5）单独的字符通常不出现在图像中，当作噪声剔除；  

三、Grouping letters into text lines:  
这里认为文本是以线性的形式出现的，一行文本时有相似之处的，如：笔画宽度、字幕宽度、高度、字符间距等。  
如果两候选字符满足：  
（1）具有相似笔画宽（中值之比小于2.0）；  
（2）高度比不超过2.0；  
（3）距离不超过宽字符的三倍；  
（4）颜色相近  
等特征，那么就对满足条件的字符聚类，形成text lines，实际上，这并不需要在文本的检测中加以处理，在OCR的过程中是可以进行的。  
[以上参考链接](http://blog.csdn.net/livecoldsun/article/details/29811583)  

一些效果图(to do)  

虽然SWT算法效果不错，但仍然会受到一些干扰，而且计算量大，较为耗时。  

### 结合方法
结合这两种经典方法，本文结合一些先验经验组合出一套检测算法。  
1. 用MSER算法提取候选文字区域，此时虽然能将文字提取到，但有大量非文字区域也被提取了出来；
2. 筛选掉比例明显不合理的候选框；
3. 提取每个候选框中识别区域的面积和周长，由于文字偏向细长，面积与周长的比例较小
4. 使用SWT算法筛选掉一部分候选框
5. 门牌号通常超过三位数字，因此只有多个数字大概在一排的候选框才是门牌  

经过一系列筛选，最终可以得到门牌的具体位置，而且字符都已经分割开，可以直接用字符识别模块识别。  

配每一步图（to do）
